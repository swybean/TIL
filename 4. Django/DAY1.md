# **Django_1일차** (3/12)
 
## **목차**
**1. Web Application**  
-클라이언트와 서버  
-Fronted & Backend

**2. Framework**  
-Web Framework  
-Django Framework  
-가상 환경  
-Django 프로젝트

**3. Django Design Pattern**  
-Project & App  
-요청과 응답

---

## **1. Web Application**

#### Web Application (web service) 개발  
인터넷을 통해 사용자에게 제공되는 소프트웨어 프로그램을 구축하는 과정  
다양한 디바이스(모바일, 태블릿, PC 등)에서 웹 브라우저를 통해 접근하고 사용할 수 있음  

#### 웹의 동작 방식  
**클라이언트-서버 구조**  
클라이어트 -> 요청 -> 서버  
클라이언트 <- 응답 <- 서버  

**클라이언트 (Client)** : 서비스를 **요청**하는 주체  
(웹 사용자의 인터넷이 연결된 장치, 웹 브라우저)  

**서버 (Server)** : 클라이언트의 요청에 **응답**하는 주체  
(웹 페이지, 앱을 저장하는 컴퓨터)


#### 웹 개발에서의 Fronted & Backend
**Frontend (프론트엔드)**  
사용자가 인터페이스(UI)를 구성하고, 사용자가 애플리케이션과 상호작용할 수 있도록 함  
HTML, CSS, JavaScript, 프론트엔드 프레임워크 등  

**Backend (백엔드)**  
**서버 측에서 동작**하며, 클라이언트의 요청에 대한 처리와 데이터베이스와의 상호작용을 담당  
서버언어(Python, Java 등) 및 프레임워크, 데이터베이스, API, 보안 등  



## **2. Framework**

**Web Framework** : 웹 애플리케이션을 빠르게 개발할 수 있도록 도와주는 도구  
(개발에 필요한 기본 구조, 규칙, 라이브러리 등을 제공)  


#### Djang
파이썬 기반의 대표적인 웹 프레임워크

**Django 특징**  
**다양성** : Python 기반으로 소셜 미디어 및 빅데이터 관리 등 광범위한 서비스 개발에 적합  
**확장성** : 대량의 데이터에 대해 빠르고 유연하게 확장할 수 있는 기능을 제공  
**보안** : 취약점으로부터 보호하는 보안 기능이 기본적으로 내장  
**커뮤니티 지원** : 개발자를 위한 지원, 문서 및 업데이트를 제공하는 활성화 된 커뮤니티  



#### 가상 환경  
Python 애플리케이션과 그에 따른 패키지들을 격리하여 관리할 수 있는 **독립적인** 실행 환경  

#### 의존성 패키지
한 소프트웨어 패키지가 다른 패키지의 기능, 코드를 사용하기 때문에 그 패키지가 존재해야만 제대로 작동하는 관계  
사용하려는 패키지가 미설치, 호환되는 버전이 아니면 오류발생 혹은 예상치 못한 동작을 보일 수 있음  

#### 패키지 목록이 필요한 이유  
venv 폴더는 패키지가 계속 설치되므로 용량이 매우 커져 push하면 안된다.  

내가 사용한 패키지 목록 텍스트 파일만 올려서 팀원이 내가 무슨 패키지를 사용했는지 알 수 있게 한다.

깃배시에서 아래 문구를 치면 만들 수 있다.  
pip freeze > requirements.txt  
-> 패키지 목록을 > 오른쪽에 있는 파일명.확장자로 만들어라


**가상 환경 & 의존성 패키지 관리**  
개발 환경에서는 각각의 프로젝트가 사용하는 패키지와 그 버전을 정확히 관리하는 것이 중요  

#### 가상환경 생성
교재 35쪽~ 보기  
새폴더에 실습한거 보기



#### Django 프로젝트 생성 전 루틴
> Django_명령어 모음.txt 참고하기
1. 가상환경 생성
2. 가상환경 활성화
3. Django 설치
4. 의존성 파일 생성 (패키지 설치시마다 진행)  
5. .gitignore 파일 생성 (첫 add 전) 
6. git 저장소 생성  
7. Django 프로젝트 생성

#### 가상환경을 사용하는 이유
의존성 관리 : 라이브러리 및 패키지를 각 프로젝트마다 독립적으로 사용 가능  
팀 프로젝트 협업 : 모든 팀원이 동일한 환경과 의존성 위에서 작업하여 버전간 충돌을 방지  

#### LTS (Long-Term-Support)  
프레임워크나 라이브러리 등의 소프트웨어에서 장기간 지원되는 안정적인 버전을 의미할 때 사용  

기업이나 대규모 프로젝트에서는 소프트웨어 업그레이드에 많은 비용과 시간이 필요하기 때문에 안정적이고 장기간 지원되는 버전이 필요  



## **3. Django Design Pattern**

**디자인 패턴** : 소프트웨어 설계에서 발생하는 문제를 해결하기 위한 일반적인 해결책  
(공통적인 문제를 해결하는 데 쓰이는 형식화 된 관행)  
('애플리케이션의 구조는 이렇게 구성하자' 라는 관행)


**MVC 디자인 패턴**  
애플리케이션을 구조화하는 대표적인 패턴   
MVC, Model, View, Controller  
데이터 & 사용자 인터페이스 & 비즈니스 로직을 분리  
-> 시각적 요소와 뒤에서 실행되는 로직을 서로 영향 없이, 독립적이고 쉽게 유지보수할 수 있는 애플리케이션을 만들기 위해서    

> Model : 데이터  
View : 사용자와 상호작용  
Controller : Model과 View 연결 관리


**MTV 디자인 패턴**  
Django에서 애플리케이션을 구조화하는 패턴   
Model, Template, View    
기존 MVC 패턴과 동일하나 명칭만 다르게 정의한 것    
View -> Template / Controller -> View  


#### Django project  
애플리케이션의 집합 (DB 설정, URL 연결, 전체 앱 설정 등을 처리)  

**Django application** : 독립적으로 작동하는 기능 단위 모듈  
(각자 특정한 기능을 담당하며 다른 앱들과 함께 하나의 프로젝트를 구성)  

> 예시 - 온라인 커뮤니티 카페  
프로젝트 : 카페 (전체 설정 담당)  
앱 : 게시글, 댓글, 회원 관리 등 (DB, 인증, 화면)



#### 앱을 사용하기 위한 순서
1. 앱 생성  
앱의 이름은 '복수형'으로 지정하는 것을 권장

2. 앱 등록  
반드시 **앱을 생성한 후** 등록해야 함  
(등록 후 생성은 불가능)



#### 프로젝트 구조
settings.py : 프로젝트의 모든 설정을 관리  

urls.py : 요청 들어오는 URL에 따라 이에 해당하는 적절한 views를 연결  

\_\_init\_\_.py : 해당 폴더를 패키지로 인식하도록 설정하는 파일

asgi.py : 비동기식 웹 서버와의 연결 관련 설정  

wsgi.py : 웹 서버와의 연결 관련 설정  

manage.py : Django 프로젝트와 다양한 방법으로 상호작용 하는 커맨드라인 유틸리티  

admin.py : 관리자용 패이지 설정

models.py : DB와 관련된 Model을 정의 (MTV패턴의 M)

views.py : HTTP 요청을 처리하고 해당 요청에 대한 응답을 반환 (url, model, template와 연계, MTV패턴의 V)

apps.py : 앱의 정보가 작성된 곳

tests.py : 프로젝트 테스트 코드를 작성하는 곳


#### 요청과 응답
1. urls.py로 요청이 들어옴
2. app 내부의 view.py로 전달
3. views.py가 models.py & templates와 app 내부에서 작동
4. view.py가 응답

**1. URLs**  
http://127.0.0.1:8000/index/로 요청이 왔을 때  
views 모듈의 view 함수 index를 호출

**2. View**  
특정 경로에 있는 template와 request 객체를 결합해 응답 객체를 반환하는 index view 함수 정의  
(모든 view 함수는 첫번째 인자로 request 요청 객체를 필수적으로 받음)  
(매개변수 이름이 request가 아니어도 되지만 그렇게 작성하지 않도록) 

**3. Template**  
articles 앱 폴더 안에 templates 폴더 생성  
templates 폴더 안에 articles 폴더 생성  
articles 폴더 안에 템플릿 파일 생성  
(폴더명은 반드시 templates여야 함, 개발자가 직접 생성해야 함)  

**Django에서 template를 인식하는 경로 규칙**
1. app폴더 / templates / articles / index.html  
2. app폴더 / templates / example.html  

Django에서는 templates까지는 기본 경로로 인식  
viwe 함수에서 해당 지점 이후의 경로를 작성해야 함  


#### 데이터 흐름에 따른 코드 작성  
```python
# URLs
path('articles/', views.index)  

# View
# URLs의 views.index가 def의 index로 들어온다. 
def index(request):
    return render(request, articles/index.html)

# Template
# articles/index.html를 View에서 받아온다. 
articles/templates/articles/index.html
```


## [참고]

#### MTV 디자인 패턴 정리

**Model** : 데이터와 관련된 로직을 처리, 응용프로그램의 데이터 구조를 정의하고 데이터베이스의 기록을 관리  

**Template** : 레이아웃과 화면을 처리, 화면상의 사용자 인터페이스 구조와 레이아웃을 정의  

**View** : Model & Template와 관련된 로직을 처리해서 응답을 반환  
클라이언트의 요청에 대해 처리를 분기하는 역할

**View 예시**  
데이터가 필요하다면 model에 접근해서 데이터를 가져오고,  
가져온 데이터를 template로 보내 화면을 구성하고,  
구성된 화면을 응답으로 만들어 클라이언트에게 반환  


#### render 함수  
주어진 템플릿을 주어진 컨텍스트 데이터와 결합하고 렌더링 된 텍스트와 함께 HttpResponse 응답 객체를 반환하는 함수  

1. request : 응답을 생성하는 데 사용되는 요청 객체
2. template_name : 템플릿 이름의 경로  
3. context : 템플릿에서 사용할 데이터 (딕셔너리 타입)


#### Django 규칙
1. urls.py에서 각 url 경로는 반드시 /로 끝남  
2. view.py에서 모든 view 함수는 **첫번째 인자로 요청객체**를 받음   
(매개변수 이름은 반드시 request로 지정)  
3. Django는 **정해진 경로**에 있는 template 파일만 읽어올 수 있음  
(app폴더/templates/ 이후)


#### 프레임워크의 규칙  
프레임워크를 사용할 때는 일정한 규칙을 따라야 하며 이는 저마다의 설계 철학 & 목표를 반영하고 있음  
(일관성 유지, 보안 강화, 유지보수성 향상, 최적화 등)  

프레임워크는 개발자에게 도움을 주는 도구와 환경을 제공하기 위해 규칙을 정해 놓은 것이며 우리는 이를 잘 활용하여, 특정 기능을 구현하는 방법을 표준화하고 개발 프로세스를 단순화할 수 있도록 해야 함

---

#### 선생님 오후 추가 설명  














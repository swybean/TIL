


'''
동빈이는 두 개의 배열 A와 B를 가지고 있다. 
두 배열은 N개의 원소로 구성되어 있으며, 배열의 원소는 모두 자연수이다. 
동빈이는 최대 K번의 바꿔치기 연산을 수행할 수 있는데. 
바꿔치기 연산이란 배열 A에 있는 원소 하나와 배열 B에 있는 원소 하나를 골라서 두 원소를 서로 바꾸는 것을 말한
다. 
동빈이의 최종 목표는 배열 A의 모든 원소의 합이 최대가 되도록 하는 것이며, 여러분은 동빈이를 도와야 한다.
N, K, 그리고 배열 A와 B의 정보가 주어졌을 때. 
최대 K번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력하는 프로그램을 작성하시오.

예를 들어 N = 5. K = 3이고 배열 A와 B가 다음과 같다고 하자.
• 배열 A = [1,2, 5, 4, 3]
• 배열 B = [5, 5, 6, 6, 5]
이 경우, 다음과 같이 세 번의 연산을 수행할 수 있다.
• 연산 1) 배열 A의 원소 1과 배열 日의 원소 6을 바꾸기
• 연산 2) 배열 A의 원소 2와 배열 日의 원소 6을 바꾸기
• 연산 3) 배열 A의 원소 3과 배열 日의 원소 5를 바꾸기

세 번의 연산 이후 배열 A와 배열 B의 상태는 다음과 같이 구성될 것이다.
• 배열 A = [6, 6, 5, 4, 5]
• 배열 B = [3,5,1,2, 5]

이때 배열 A의 모든 원소의 합은 26이 되며, 이보다 더 합을 크게 만들 수는 없다. 따라서 이 예시의
정답은 26이 된다

입력조건 
• 첫 번째 줄에 N.K가 공백으로구분되어 입력된다. (1 < N < 100,000,0 < K < N)
• 두 번째 줄에 배열 A의 원소들이 공백으로 구분되어 입력된다. 
  모든 원소는 10,000,000보다 작은 자연수이다.
• 세 번째 줄에 배열 A의 원소들이 공백으로 구분되어 입력된다. 
  모든 원소는 10,000,000보다 작은 자연수입니다.

출력 조건 
• 최대 수번의 바꿔치기 연산을 수행하여 만들 수 있는 배열 A의 모든 원소의 합의 최댓값을 출력한다
'''
# A에서 가장 작은 원소부터 정렬
# B에서 가장 작은 원소부터 정렬
# A의 1번 원소 vs B의 마지막 원소를 비교해서 B의 원소가 더 큰 경우에만 바꿔치기 실행

# N, K를 입력한다. / N : 원소의 수, K : 바꿔치기 가능 횟수
N, K = int(input().split())

# 배열 A 입력하기 및 리스트화
A = list(map(int, input().split()))
# 배열 B 입력하기 및 리스트화
B = list(map(int, input().split()))


# A, B 리스트 정렬 (가장 작은 원소부터 정렬)
for i in range(N):
    for j in range(i + 1, N):
        if A[i] > A[j]:
            A[i], A[j] = A[j], A[i]
        if B[i] > B[j]:
            B[i], B[j] = B[j], B[i] 

# range(K)의 범위에서 i를 찾아서 반복문 시작
for i in range(K):
    # A리스트의 첫번째 원소 A[i]가 B리스트의 마지막 원소 B[N-i-1]보다 작으면
    if A[i] < B[N-i-1]:
        # 그 두 리스트의 원소를 바꾼다.
        A[i], B[N-i-1] = B[N-i-1], A[i]
    # 작지 않고 크거나 같으면 그만 둔다.
    # 더 클 때 바꾸면 오히려 합이 작아지고, 같을 때는 의미 없기 때문이다.
    else:
        break

# A리스트의 모든 원소의 합 구하기
print(sum(A)) 
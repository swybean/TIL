T = int(input())
for test_case in range(1, T + 1):
    N, M1, M2 = map(int, input().split())  # 블럭 개수, 탑1 층수, 탑2 층수
    arr = list(map(int, input().split()))  # 블럭 무게 리스트

    tap1 = []  # 첫번째 탑 리스트 생성
    tap2 = []  # 두번째 탑 리스트 생성

    cost_tap1 = 0   # 첫번째 탑 가격 총합
    cost_tap2 = 0   # 두번째 탑 가격 총합
    result = 0      # 정답, 탑 2개의 가격 총합

    arr.sort(reverse=True)  # 주어진 블럭 무게 리스트 내림차순 정렬

    # 첫 번째 과정 (무거운 숫자들 부터 탑1, 탑2에 번갈아 가면서 넣기)
    # i를 2칸씩 건너뛰면서 순회
    for i in range(0, N, 2):
        # 탑 2개 전부 아직 최고층까지 쌓지 않았으면 각 탑에 i, i+1을 넣고 해당 숫자를 -1로 변경
        if len(tap1) < M1 and len(tap2) < M2:
            tap1.append(arr[i])
            arr[i] = -1
            tap2.append(arr[i + 1])
            arr[i+1] = -1
        # 탑1이 최고층까지 찼으면 탑2에 넣고 해당 숫자를 -1로 변경
        elif len(tap1) == M1:
            tap2.append(arr[i])
            arr[i] = -1
        # 탑2가 최고층까지 찼으면 탑1에 넣고 해당 숫자를 -1로 변경
        elif len(tap2) == M2:
            tap1.append(arr[i])
            arr[i] = -1

    # 두 번째 과정 (아직 남은 숫자들 마저 탑에 다 넣기)
    # 첫 번째 과정을 거치면 한 탑이 가득 찬 상태에서 순회가 멈춤
    # 아직 arr 에서 어느 탑에도 들어가지 않은 숫자들이 있는데 해당 숫자들을 비어있는 탑에 다 넣어야 함
    # arr을 순회하면서 j를 찾을건데
    for j in arr:
        # j가 -1이 아니라면 (이미 tap1, tap2에 넣은 숫자를 -1로 바꿨으니 -1 아니면 아직 안넣은 숫자)
        if j != -1:
            # 탑1이 최고층까지 찼으면 탑2에 넣는다.
            if len(tap1) == M1:
                tap2.append(j)
            # 탑2가 최고층까지 찼으면 탑1에 넣는다.
            elif len(tap2) == M2:
                tap1.append(j)

    # 세 번째 과정 (탑 리스트들 정렬시키기)
    # 완성된 tap1, tap2 리스트를 내림차순으로 정렬시키기
    # 최소비용을 위해서는 무거운(높은숫자) 블럭을 저층에 위치시켜야 한다.
    tap1.sort(reverse=True)
    tap2.sort(reverse=True)

    # 네 번째 과정 (비용 구하기)
    # a를 탑1의 길이만큼 탐색
    for a in range(len(tap1)):
        # 인덱스 a번째 숫자 x (a+1)을 cost_tap1에 추가 (무게 x 층수를 cost_tap1에 추가)
        # 층수는 인덱스 번호 +1 이기 때문에
        cost_tap1 += tap1[a] * (a + 1)

    # b를 탑2의 길이만큼 탐색
    for b in range(len(tap2)):
        # 인덱스 b번째 숫자 x (b+1)을 cost_tap2에 추가 (무게 x 층수를 cost_tap2에 추가)
        # 층수는 인덱스 번호 +1 이기 때문에
        cost_tap2 += tap2[b] * (b + 1)

    # 최종 결과는 cost_tap1 + cost_tap2를 합친 것
    result = cost_tap1 + cost_tap2

    # 결과 출력
    print(f'#{test_case} {result}')

    # print(arr)
    # print(tap1)
    # print(tap2)
    # print(cost_tap1)
    # print(cost_tap2)
    # print(result)

'''
최소비용은 무거운것들을 1층에 넣고 가벼울수록 고층에 넣어야 함
가장 무거운 블럭부터 순서대로 tap1과 tap2에 번갈아 넣어야 함
중간에 한 탑이 최고층까지 다 찼으면 남은 숫자는 전부 나머지 탑으로 넣기
인덱스 번호 != 층수인거 꼭 기억하기!!!!!!!!!!!!!!!!! 층수는 인덱스 번호 + 1해야함!!!!!!!!!!!!!!!
인덱스 0 = 1층, 인덱스 1 = 2층!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
'''

'''
arr에서 같은 숫자가 있을 때 중복되는 숫자가 비어있는 탑이 있어도 탑에 안들어감
정렬이 안됨
예를 들어서 아래 경우
1
5 0 5
1 1 5 4 3

[5, 4, 3, 1, 1] # arr
[]              # tap1
[4, 1, 5, 3]    # tap2
0               # cost_tap1
33              # cost_tap2

이럴 때 tap2에 1이 2개 들어가야하는데 1개만 들어감

숫자를 탑에 집어 넣을 때마다 해당 숫자를 -1로 바꾸고 (무게는 무조건 1이상이니까 차후 혼동 없도록)
남은 수 중에서 -1이 아닌데 탑에 안들어간걸 아직 비어있는 탑에 다 넣기

'''

'''
[7, 5, 4, 3, 1]
#1 29
[7, 6, 5, 4, 3, 2, 1]
#2 64
[9, 8, 7, 6, 5, 4, 3, 2, 1]
#3 95
[11, 11, 9, 9, 8, 8, 7, 7, 6, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1]
#4 414
[997, 975, 952, 946, 933, 887, 872, 868, 865, 862, 792, 748, 725, 719, 713, 702, 701, 700, 694, 664, 664, 646, 637, 635, 552, 537, 530, 518, 463, 448, 396, 392, 338, 327, 318, 282, 207, 198, 192, 189, 182, 177, 161, 105, 76, 61, 41, 22, 13, 3]
#5 227672

#1 29
#2 63
#3 95
#4 447
#5 226521
'''


'''
크기와 모양이 같은 N개의 블록을 쌓아 두 개의 탑을 만들려고 한다.

단, 첫 번째 탑은 M1층, 두 번째 탑은 M2층이 되도록 쌓아야 하며, M1 + M2 = N 이 항상 보장된다.
※ 가장 밑의 블록을 1층으로 정의한다.

각 블록의 무게는 서로 다를 수 있으며, 블록을 쌓을 때는 무게 x 층 만큼의 비용이 발생한다.
예를 들어, 무게 10kg, 5kg, 15kg 3개의 블록을 순서대로 쌓을 경우 비용은 아래와 같다.
#######
5 2 3
7 3 4 1 5
#1 29
7 3 1 
5 4

[제한 조건]
1. 1 ≤ N ≤ 50 , 1 ≤ M1 ≤ 50 , 1 ≤ M2 ≤ 50 
2. M1 + M2 = N 
3. 각 블록의 무게는 1kg 이상 1,000kg 이하이다.

[입력]
가장 첫 줄에는 테스트 케이스의 개수 T가 주어지고, 그 아래로 각 테스트 케이스가 주어진다.
각 테스트 케이스의 첫째 줄에는 N, M1, M2가 주어지고, 둘째 줄에는 각 블록의 무게가 주어진다.

[출력]
테스트 케이스 T에 대한 결과는 "#T"를 찍고, 한 칸 띄고, 정답을 출력한다.
(T는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)
'''

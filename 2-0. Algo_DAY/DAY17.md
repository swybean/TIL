# **알고리즘_17일차** (2/27)
 
---

## **목차**
### **완전검색&그리디**
1. 반복과 재귀
2. 완전검색기법
3. 순열
4. 부분집합
5. 조합
6. 탐욕 알고리즘
7. 활동 선택 문제
8. Baby-jin

---


## **1. 반복(Iteration)과 재귀(Recursion)**

### **학습 목표**
> 재귀적 알고리즘의 특성을 이해하고 이를 구현하기 위한 재귀 호출에 대해 학습

> 완전 검색의 개념을 이해, 완전 검색을 통한 문제해결방법에 대해 학습

> 조합적 문제(Combinatorial Problems)에 대한 완전 검색 방법에 대해 이해  
(순열, 조합, 부분집합을 생성하는 알고리즘)

> 탐욕 알고리즘 기법의 개념과 주요 특성을 이해

---

### **반복과 재귀**
> 반복과 재귀는 유사한 작업을 수행할 수 있다.

> 반복은 수행하는 작업이 완료될 때 까지 계속 반복 (for, while 구조)

> 재귀는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법  
-> 하나의 큰 문제를 해결할 수 있는 더 작은 문제로 쪼개고 결과들을 결합 (재귀 함수로 구현)

---

### **반복구조**
> 초기화 : 반복되는 명령문을 실행하기 전에 (한번만) 조건 검사에 사용할 변수의 초기값 설정  

> 조건검사 (check control expression)

> 반복할 명령문 실행 (action)

> 업데이트 (loop update)  
무한 루트가 되지 않게 조건이 거짓이 되게 한다.

---

### **재귀적 알고리즘**
재귀적 정의는 두 부분으로 나뉜다.  
> **하나 또는 그 이상의 기본 경우(basis case or rule)**  
집합에 포함되어 있는 원소로 induction을 생성하기 위한 시드(seed) 역할

> **하나 또는 그 이상의 유도된 경우(inductive case or rule)**   
새로운 집합의 원소를 생성하기 위해 결합되어지는 방법

### **재귀함수**
> 함수 내부에서 직간접적으로 자기 자신을 호출하는 함수  

> 일반적으로 재귀적 정의를 이용하여 재귀함수를 구현한다.  
따라서, 기본 부분(basis part)와 유도 부분(inductive part)로 구분된다.  
반복 구조에 비해 간결하고 이해하기 쉽다. 

>함수호출은 프로그램 메모리 구조에서 스택을 사용한다.  
즉, 재귀호출은 반복적인 스택의 사용을 의미하며 메모리 및 속도에서 성능저하가 발생한다.

> **입력값 N이 커질수록 재귀 알고리즘은 반복에 비해 비효율적일 수 있다.**

---

### **재귀함수의 특징**
> int 타입 객체를 전달하면 **값만 복사**된다.

> 함수가 끝나면 Main이 아니라, **해당 함수를 호출했던 곳으로 돌아온다.**

---

### **무한 재귀호출 막기**
> 기저조건 (base case)  
*예시 라이브 다시보기 혹은 사이트 교재 찾아보기





---

### **반복과 재귀의 비교**

||재귀|반복|
|:---:|:---:|:---:|
|종료|재귀함수 호출이 종료되는 베이스 케이스(base case)|반복문의 종료 조건|
|수행 시간|(상대적) 느림|빠름|
|메모리 공간|(상대적) 많이 사용|적게 사용|
|소스 코드 길이|짧고 간결|길다|
|소스 코드 형태|선택 구조(if, else)|반복 구조(for, while)|
|무한 반복시|스택 오버플로우|CPU를 반복해서 점유|

---


## **2. 완전검색**
> 모든 경우의 수를 생성하고 테스트하기 때문에 수행속도는 느리지만, 해답을 찾아내지 못할 확률이 작다.  

> 이를 기반으로 그리디 기법, 동적 계획법을 이용해서 효율적인 알고리즘을 찾을 수 있다.

> 완전검색으로 접근하여 해답을 도출한 후, 성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 방식이 바람직하다.



# **알고리즘_3일차** (1/31)



## **목차**
###  배열(List)2 (Array 2)
1. 배열 : 2차원 배열
2. 부분집합 생성
3. 이진 검색 (바이너리 서치, Binary Search)
4. 선택 정렬 (Selection Sort)
5. 셀렉션 알고리즘 (Selection Algorithm)


---



## **1. 배열 : 2차원 배열**

### **1-1. 2차원 배열**
> 1차원 List를 묶어놓은 List
>
> 2차원 이상의 다차원 List는 차원에 따라 index를 선언
>
> 2차원 List의 선언 : 세로길이(행 개수), 가로길이(열 개수)를 필요로 함
>
> Python에서는 데이터 초기화를 통해 변수선언 및 초기화 가능

> arr = [[0, 1, 2, 3], [4, 5, 6, 7]]  
> (2행 4열의 2차원 List)

```python
'''input을 이용한 2차원 리스트 코드 예시
3
1 2 3
4 5 6
7 8 9
를 코드로 입력하려면'''

N = int(input)
arr = [list(map(int, input().split())) for i in range(N)]

# 1 2 3이 아닌 123 처럼 공백 없이 주어지면 .split()을 제외한다.

# 빈 2차원 배열 만드는 방법 (중요!!!!!!)
empty_arr = [[0] * N for _ in range(N)]
```
---



### **1-2. 배열의 접근**

#### **배열 순회**
> n X m 배열의 n*m개의 모든 원소를 빠짐없이 조사하는 방법  
> 종류 : 행 우선 조회, 열 우선 조회, 지그재그 순회

```python
# i = 행의 좌표, j = 열의 좌표
# n = 행 갯수, m = 열 갯수

# 1. 행 우선 조회
for i in range(n):
    for j in range(m):
        f(array[i][j]) # 필요한 연산 수행

# 2. 열 우선 조회
for j in range(m):
    for i in range(n):
        f(array[i][j]) # 필요한 연산 수행

# 3. 지그재그 순회
for i in range(n):
    for j int range(m):
        f(array[i][j + (m-1-2*j) * (i%2)])
```

---

#### **델타를 이용한 2차 배열 탐색**
> 2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법
>
> 인덱스 (i, j)인 칸의 상하좌우 칸(ni, nj)


#### **2차 배열의 한 좌표에서 4방향의 인접 배열 요소를 탐색하는 방법**  

```python
arr[0...N-1][0...N-1] # NxN 배열
di[] <- [0, 1, 0, -1] #
dj[] <- [1, 0, -1, 0]

for i : 0 -> N-1:
    for j : 0 -> N-1:
        for k in range(4):
            ni <- i + di[k]
            nj <- j + dj[k]
            if 0 <= nu < N and 0 <= nj < N
            # 유효한 인덱스면
            f(arr[ni][nj])
```
> 교재 8~9쪽

```python
# 강의시간 선생님 실습 교재 8쪽
i = 3
j = 4

# 방향별로 더할 값
di = [0, 1, 0, -1]
dj = [1, 0, -1, 0]

for k in range(4):
    ni = i + di[k]
    nj = j + dj[k]
    print(ni, nj) 

# 특정 칸의 상하좌우 4칸 좌표를 출력하는 방법 (중요!!)
N = 5
arr = [[0] * N for _ in range(N)]

for i in range(N):
    for j in range(N):
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < N and 0 <= nj < N:
                print(arr[ni][nj], end='') 
        print()
```

---

#### **전치 행렬**
> 1 2 3  
4 5 6  
7 8 9  
에서 2와 4, 3과 7, 6과 8의 자리를 바꾸는 것

```python
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1,2,3], [4,5,6], [7,8,9]]   # 3x3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
print(arr)
```

#### 연습문제 1-1 (교재 12쪽)
> 5x5 2차 배열에 25개 숫자를 저장하고, 대각선 원소의 합을 구하시오.

```python
N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)]
total = 0

for i in range(N):
    total += arr[i][i]  # 오른쪽 아래 대각선
    total += arr[i][N-1-i]
if N % 2:   # 크기가 홀수인 경우
    total -= arr[N//2][N//2]    # 중심원소가 중복되므로
print(total)
```
---

#### 연습문제 1-2 (교재 13쪽)
> 5x5 2차 배열에 25개 숫자를 저장하고, 25개의 각 요소에 대해서 그 요소와 이웃한 요소와의 차의 절대값을 구하시오.  
> 아래 코드 공식마냥 외워두기!!!

```python
di = [0, 1, 0, -1]
dj = [1, 0, -1, 0]

N = int(input())
arr = [list(map(int, input().split())) for _ in range(N)] # 5x5 2차 배열에 25개의 숫자를 저장하고
total = 0
for i in range(N): # 25개의 각 요소에 대해서  arr[i][j]
    for j in range(N):
        for k in range(4):
            ni = i + di[k]
            nj = j + dj[k]
            if 0 <= ni < N and 0 <= nj < N:
                # 차의 절대값을 구하시오, 총합을 구하시오.
                total += abs(arr[ni][nj] - arr[i][j])  
print(total)
```

---


## **2. 부분집합**

### **2-1. 부분집합 합 (Sunset Sum) 문제**
> 유한 개의 정수로 이루어진 집합이 있을 때,  
> 이 집합의 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제  

> 예를 들어, [-7, -3, -2, 5, 8]인 집합이 있을 때,  
> [-3, -2, 5]는 이 집합의 부분집합이면서 (-3) + (-2) + 5 = 0 이므로 답은 참이다.

---

### **2-2. 부분집합 생성하기**
> 완전검색 기법으로 부분집합 합 문제를 풀기 위해서는,  
> 우선 집합의 모든 부분집합을 생성한 후에 각 부분집합의 합을 계산해야 한다.

#### **부분집합의 수**
> 집합의 원소가 n개일 때, 공집합을 포함한 부분집합의 수는 $2^n$개 이다.  

> 이는 각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수와 같다.

> 예를 들어, {1, 2, 3, 4} 는 (2 x 2 x 2 x2) = 16가지

---

#### **부분집합 생성 코드**
> 각 원소가 부분집합에 포함되었는지를 loop를 이용하여 확인하고 부분집합을 생성하는 방법  
```python
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i  # 0번 원소
    for j in range(2):
        bit[1] = j  # 1번 원소
        for k in range(2):
            bit[2] = k  # 2번 원소
            for l in range(2):
                bit[3] = l  # 3번 원소
                print_sunset(bit)
                # 생성된 부분집합 출력
```
---

#### **비트 연산자**

|연산자|내용|
|------|---|
| & |비트 단위로 AND 연산을 한다.|
|\||비트 단위로 OR 연산을 한다.|
|<<|피연산자의 비트 열을 왼쪽으로 이동시킨다.|
|>>|피연산자의 비트 열을 왼쪽으로 이동시킨다.|

#### **<< 연산자**
> **1 << n**   
> 원소가 n개일 경우의 모든 부분집합의 수를 의미 ($2^n$)

#### **&연산자**
> **i & (1<<j)**   
> i의 j번째 비트가 1인지 아닌지를 검사한다.

---

#### **비트연산자 사용한 부분집합 생성 코드**
> 보다 간결하게 부분집합을 생성하는 방법  
```python
arr = [3,6,7,1,5,4]

n = len(arr)    # n: 원소의 개수

for i in range(1<<n):   # 1<<n: 부분집합의 개수
    for j in range(n):  # 원소의 수만큼 비트를 비교
        if i & (1<<j):  # i의 j번 비트가 1인 경우
            print(arr[j], end=" ")  # j번 원소 출력
    print()
print()

```
---

#### 연습문제 2 (교재 22쪽)
> 10개의 정수를 입력 받아 부분집합의 합이 0이 되는 것이 존재하는지를 계산하는 함수를 작성해보자.

> 정수 : -7, -5, 2, 3, 8, -2, 4, 6, 9

```python
def f(arr, N):
    for i in range(1, 1 << n):   
        s = 0
        for j in range(n): 
            if i & (1<<j): 
                s += arr[j]
        if s == 0:
            return True
    return False
        
N = int(input())
arr = list(map(int, input().split()))

print(f(arr, N))
```
---


## **3. 검색**
> 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

> 목적하는 탐색 키를 가진 항목을 찾는 것  
> 탐색 키(search key) : 자료를 구별하여 인식할 수 있는 키

> 검색의 종류 : 순차 검색, 이진 검색, 해쉬

---

### **3-2. 순차 검색 (Sequential Search)**
> 일렬로 되어 있는 자료를 순서대로 검색하는 방법

> 가장 간단하고 직관적인 검색 방법  
> 배열, 연결리스트 등 순차구조로 구현된 자료구조에서 원하는 항목을 찾을 때 유용함  
> 알고리즘이 단순하여 구현이 쉽지만, 검색 대상의 수가 많은 경우에는 수행시간이 급격히 증가해 비효율적

> 2가지 경우
1. 정렬되어 있지 않은 경우
2. 정렬되어 있는 경우

---

#### **정렬되어 있지 않은 경우**
> **검색과정**  
1. 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.  
2. 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환  
3. 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 검색 실패

> 찾고자 하는 원소의 순서에 따라 비교회수가 결정됨
 
> 첫 번째 원소를 찾을 때는 1번, 두 번째 원소는 2번...  
> 정렬되지 않은 자료에서의 순차 검색의 평균 비교 회수  
> 시간 복잡도: O(n)

```python
def sequential_search(a, n, key):
    i <- 0
    while i < n and a[i] != key:
        i <- i + 1
    if i < n:
        return i
    else:
        return -1
```

---

#### **정렬되어 있는 경우**
> **검색과정**  
1. 자료가 오름차순으로 정렬된 상태에서 검색을 실시한다고 가정
2. 자료를 순차적으로 검색하면서 키 값을 비교
3. 원소의 키 값이 검색대상의 키 값보다 크면 찾는 원소가 없다는 것이므로 검색 종료

> 정렬되어 있으므로, 검색 실패를 반환하는 경우 평균 비교 회수가 반으로 줄어듬

> 시간 복잡도: O(n)

```python
def sequential_search(a, n, key):
    i <- 0
    while i < n and a[i] < key:
        i <- i + 1
    if i < n and a[i] == key:
        return i
    else:
        return -1
```

---


### **3-3. 이진 검색 (바이너리 서치, Binary Search)**















